package commands

import (
	"crypto/subtle"
	"fmt"
	"html/template"
	"io"
	"io/fs"
	"net/http"
	"os"
	"path"
	"strings"

	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
	"github.com/labstack/gommon/log"
	"github.com/multisig-labs/panopticon/pkg/contracts"
	"github.com/pkg/browser"
	"github.com/spf13/cobra"
)

// The embedded content after cd-ing into /public
var contentSub fs.FS

// TemplateRenderer is a custom html/template renderer for Echo framework
type TemplateRenderer struct {
	templates *template.Template
}

type reqParams struct {
	Status       uint   `query:"status"`
	NodeID       string `query:"nodeid"`
	Index        uint64 `query:"index"`
	Limit        uint64 `query:"limit"`
	Offset       uint64 `query:"offset"`
	TemplateName string `query:"templateName"`
}

// Render renders a template document
func (t *TemplateRenderer) Render(w io.Writer, name string, data interface{}, c echo.Context) error {
	log.Debugf("render %s", name)
	// Add global methods if data is a map
	if viewContext, isMap := data.(map[string]interface{}); isMap {
		viewContext["reverse"] = c.Echo().Reverse
	}

	// https://stackoverflow.com/questions/36617949/how-to-use-base-template-file-for-golang-html-template
	tmpl := template.Must(t.templates.Clone())
	// contentSub = os.DirFS("./public")
	// template.ParseFS(contentSub, "*.html")
	// tmpl = template.Must(tmpl.ParseFS(contentSub, "*.html"))
	tmpl = template.Must(tmpl.ParseFS(contentSub, name))
	return tmpl.ExecuteTemplate(w, name, data)
}

func serverCommand() *cobra.Command {
	var host string
	var port int
	var authtoken string
	var verbose bool

	cmd := &cobra.Command{
		Use:   "server",
		Short: "Start the Panopticon server process",
		Run: func(c *cobra.Command, args []string) {

			// PANOPTICON_AUTHTOKEN env will override cli flag
			atFromEnv, ok := os.LookupEnv("PANOPTICON_AUTHTOKEN")
			if ok {
				log.Info("Using PANOPTICON_AUTHTOKEN from env")
				authtoken = atFromEnv
			}

			log.SetLevel(0)
			startServer(authtoken, host, port, verbose)
		},
	}

	cmd.Flags().StringVar(&host, "host", "0.0.0.0", "IP addr the server should listen on")
	cmd.Flags().IntVar(&port, "port", 8000, "TCP port the server should listen on")
	cmd.Flags().StringVar(&authtoken, "authtoken", "", "HTTP BasicAuth admin:<authtoken>")
	cmd.Flags().BoolVar(&verbose, "v", false, "Verbose logging")
	return cmd
}

func startServer(authtoken string, host string, port int, verbose bool) {
	var err error

	e := echo.New()
	e.HideBanner = true
	e.Debug = true // Show more detailed errors in json response
	e.Use(middleware.CORS())

	if authtoken != "" {
		e.Use(middleware.BasicAuth(func(username, password string, c echo.Context) (bool, error) {
			if subtle.ConstantTimeCompare([]byte(username), []byte("admin")) == 1 &&
				subtle.ConstantTimeCompare([]byte(password), []byte(authtoken)) == 1 {
				return true, nil
			}
			return false, nil
		}))
	}

	e.Use(middleware.RecoverWithConfig(middleware.RecoverConfig{
		LogLevel: 4, // ERROR level
	}))

	if verbose {
		e.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{
			Skipper:          middleware.DefaultSkipper,
			Format:           `{"time":"${time_custom}","remote_ip":"${remote_ip}", "host":"${host}","method":"${method}","uri":"${uri}", "status":${status},"error":"${error}","bytes_out":${bytes_out}}` + "\n",
			CustomTimeFormat: "2006-01-02 15:04:05",
		}))
	}

	if verbose {
		fmt.Println("Ignoring embedded content, serving from /public")
		contentSub = os.DirFS("./public")
	} else {
		// Basically "cd" into the /public folder
		contentSub, err = fs.Sub(content, "public")
		if err != nil {
			panic(err)
		}
	}

	renderer := &TemplateRenderer{
		templates: template.Must(template.ParseFS(contentSub, "*.html")),
	}
	e.Renderer = renderer

	// ROUTES

	contr, err := contracts.NewContracts("https://anr.fly.dev", "0xAE77fDd010D498678FCa3cC23e6E11f120Bf576c")
	if err != nil {
		panic(err)
	}

	e.GET("/contracts/MinipoolManager/FetchMinipool", func(c echo.Context) error {
		p := new(reqParams)
		if err := c.Bind(p); err != nil {
			return err
		}

		// var result []interface{}
		// err := contr.MinipoolManagerRaw.Call(nil, &result, method, p)
		result, err := contr.FetchMinipool(p.NodeID)
		if err != nil {
			return echo.NewHTTPError(http.StatusUnprocessableEntity, err.Error())
		}
		return c.JSON(http.StatusOK, result)
	})

	// Autocreate routes for any .html files in /public that do not start with "_"
	fs.WalkDir(contentSub, ".", func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		fname := d.Name()
		if strings.HasSuffix(fname, ".html") && !strings.HasPrefix(fname, "_") {
			if verbose {
				println("Autogenerated Route => Path:", path, " Route:", PathFromFilenameWithoutExtension(fname))
			}
			e.GET(PathFromFilenameWithoutExtension(fname), func(c echo.Context) error {
				return c.Render(http.StatusOK, fname, map[string]interface{}{
					"Title": fmt.Sprintf("Panopticon - %s", TitleFromFilename(fname)),
				})
			})

		}
		return nil
	})

	e.GET("/", func(c echo.Context) error {
		return c.Redirect(http.StatusMovedPermanently, "/home")
	})

	// Serve static files in public/
	e.GET("/*", echo.WrapHandler(http.FileServer(http.FS(contentSub))))

	listenAddr := fmt.Sprintf("%s:%v", host, port)

	browser.OpenURL(fmt.Sprintf("http://localhost:%d", port))

	if err := e.Start(listenAddr); err != http.ErrServerClosed {
		e.Logger.Fatal(err)
	}
}

func FilenameWithoutExtension(fn string) string {
	return strings.TrimSuffix(fn, path.Ext(fn))
}

func PathFromFilenameWithoutExtension(fn string) string {
	s := strings.TrimSuffix(fn, path.Ext(fn))
	return fmt.Sprintf("/%s", s)
}

func TitleFromFilename(fn string) string {
	return strings.ToTitle(FilenameWithoutExtension(fn))
}
